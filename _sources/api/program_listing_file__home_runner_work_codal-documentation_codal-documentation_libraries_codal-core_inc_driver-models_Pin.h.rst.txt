
.. _program_listing_file__home_runner_work_codal-documentation_codal-documentation_libraries_codal-core_inc_driver-models_Pin.h:

Program Listing for File Pin.h
==============================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_codal-documentation_codal-documentation_libraries_codal-core_inc_driver-models_Pin.h>` (``/home/runner/work/codal-documentation/codal-documentation/libraries/codal-core/inc/driver-models/Pin.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   /*
   The MIT License (MIT)
   
   Copyright (c) 2017 Lancaster University.
   
   Permission is hereby granted, free of charge, to any person obtaining a
   copy of this software and associated documentation files (the "Software"),
   to deal in the Software without restriction, including without limitation
   the rights to use, copy, modify, merge, publish, distribute, sublicense,
   and/or sell copies of the Software, and to permit persons to whom the
   Software is furnished to do so, subject to the following conditions:
   
   The above copyright notice and this permission notice shall be included in
   all copies or substantial portions of the Software.
   
   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
   THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
   FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
   DEALINGS IN THE SOFTWARE.
   */
   
   #ifndef CODAL_PIN_H
   #define CODAL_PIN_H
   
   #include "CodalConfig.h"
   #include "CodalComponent.h"
   #include "PinPeripheral.h"
                                                             // Status Field flags...
   #define IO_STATUS_DIGITAL_IN                0x0001        // Pin is configured as a digital input, with no pull up.
   #define IO_STATUS_DIGITAL_OUT               0x0002        // Pin is configured as a digital output
   #define IO_STATUS_ANALOG_IN                 0x0004        // Pin is Analog in
   #define IO_STATUS_ANALOG_OUT                0x0008        // Pin is Analog out
   #define IO_STATUS_TOUCH_IN                  0x0010        // Pin is a makey-makey style touch sensor
   #define IO_STATUS_EVENT_ON_EDGE             0x0020        // Pin will generate events on pin change
   #define IO_STATUS_EVENT_PULSE_ON_EDGE       0x0040        // Pin will generate events on pin change
   #define IO_STATUS_INTERRUPT_ON_EDGE         0x0080        // Pin will generate events on pin change
   #define IO_STATUS_ACTIVE_HI                 0x0100        // Pin is ACTIVE_HI if set, or ACTIVE_LO if clear
   #define IO_STATUS_WAKE_ON_ACTIVE            0x0200        // Pin should trigger power manager wake-up
   
   #define DEVICE_PIN_MAX_OUTPUT             1023
   
   #define DEVICE_PIN_MAX_SERVO_RANGE        180
   #define DEVICE_PIN_DEFAULT_SERVO_RANGE    2000
   #define DEVICE_PIN_DEFAULT_SERVO_CENTER   1500
   
   #define DEVICE_PIN_EVENT_NONE             0
   #define DEVICE_PIN_INTERRUPT_ON_EDGE      1
   #define DEVICE_PIN_EVENT_ON_EDGE          2
   #define DEVICE_PIN_EVENT_ON_PULSE         3
   #define DEVICE_PIN_EVENT_ON_TOUCH         4
   
   #define DEVICE_PIN_EVT_RISE               2
   #define DEVICE_PIN_EVT_FALL               3
   #define DEVICE_PIN_EVT_PULSE_HI           4
   #define DEVICE_PIN_EVT_PULSE_LO           5
   
   namespace codal
   {
       using namespace codal;
   
       enum PinCapability: uint8_t
       {
           PIN_CAPABILITY_DIGITAL = 0x01,
           PIN_CAPABILITY_ANALOG = 0x02,
           PIN_CAPABILITY_AD = PIN_CAPABILITY_DIGITAL | PIN_CAPABILITY_ANALOG,
           PIN_CAPABILITY_ALL = PIN_CAPABILITY_DIGITAL | PIN_CAPABILITY_ANALOG
       };
   
       typedef uint8_t PinNumber;
   
       enum class PullMode : uint8_t
       {
           None = 0,
           Down,
           Up
       };
   
       class Pin
       {
           protected:
           PinCapability capability;
           PullMode pullMode;
   
           public:
           uint16_t status;
           uint16_t id;
   
           void (*gpio_irq)(int state);
   
           // the name of this pin, a number that maps to hardware.
           PinNumber name;
   
           Pin(int id, PinNumber name, PinCapability capability)
           {
               this->status = IO_STATUS_ACTIVE_HI;
               this->id = id;
               this->name = name;
               this->capability = capability;
               this->gpio_irq = NULL;
           }
   
           virtual int setDigitalValue(int value)
           {
               return DEVICE_NOT_IMPLEMENTED;
           }
   
           virtual int getDigitalValue()
           {
               return DEVICE_NOT_IMPLEMENTED;
           }
   
           virtual int getDigitalValue(PullMode pull)
           {
               setPull(pull);
               return getDigitalValue();
           }
   
           virtual int setAnalogValue(int value)
           {
               return DEVICE_NOT_IMPLEMENTED;
           }
   
           virtual int setServoValue(int value, int range = DEVICE_PIN_DEFAULT_SERVO_RANGE, int center = DEVICE_PIN_DEFAULT_SERVO_CENTER)
           {
               return DEVICE_NOT_IMPLEMENTED;
           }
   
           virtual int getAnalogValue()
           {
               return DEVICE_NOT_IMPLEMENTED;
           }
   
           virtual int isInput()
           {
               return (status & (IO_STATUS_DIGITAL_IN | IO_STATUS_ANALOG_IN)) == 0 ? 0 : 1;
           }
   
           virtual int isOutput()
           {
               return (status & (IO_STATUS_DIGITAL_OUT | IO_STATUS_ANALOG_OUT)) == 0 ? 0 : 1;
           }
   
           virtual int isDigital()
           {
               return (status & (IO_STATUS_DIGITAL_IN | IO_STATUS_DIGITAL_OUT)) == 0 ? 0 : 1;
           }
   
           virtual int isAnalog()
           {
               return (status & (IO_STATUS_ANALOG_IN | IO_STATUS_ANALOG_OUT)) == 0 ? 0 : 1;
           }
   
           virtual int isTouched()
           {
               return DEVICE_NOT_IMPLEMENTED;
           }
   
           virtual int setServoPulseUs(uint32_t pulseWidth)
           {
               return DEVICE_NOT_IMPLEMENTED;
           }
   
           virtual int setAnalogPeriod(int period)
           {
               return setAnalogPeriodUs(((uint32_t)period)*1000);
           }
   
           virtual int setAnalogPeriodUs(uint32_t period)
           {
               return DEVICE_NOT_IMPLEMENTED;
           }
   
           virtual uint32_t getAnalogPeriodUs()
           {
               return DEVICE_NOT_IMPLEMENTED;
           }
   
           virtual int getAnalogPeriod()
           {
               return (int) (getAnalogPeriodUs()/1000);
           }
   
           virtual int setPull(PullMode pull)
           {
               return DEVICE_NOT_IMPLEMENTED;
           }
   
           virtual int drainPin()
           {
               return DEVICE_NOT_IMPLEMENTED;
           }
   
           virtual int setIRQ(void (*gpio_interrupt)(int))
           {
               this->gpio_irq = gpio_interrupt;
               return DEVICE_OK;
           }
   
           virtual int getPulseUs(int timeout)
           {
               return DEVICE_NOT_IMPLEMENTED;
           }
   
           virtual int eventOn(int eventType)
           {
               return DEVICE_NOT_IMPLEMENTED;
           }
   
           virtual int getAndSetDigitalValue(int value)
           {
                 if (isInput() && getDigitalValue() == !value)
                 {
                     setDigitalValue(value);
                     return DEVICE_OK;
                 }
                 return DEVICE_BUSY;
           }
           
           int isActive()
           {
               return !(status & IO_STATUS_ACTIVE_HI) == !getDigitalValue();
           }
   
           void setPolarity(int polarity)
           {
               if (polarity)
                   status |= IO_STATUS_ACTIVE_HI;
               else
                   status &= ~IO_STATUS_ACTIVE_HI;
           }
   
           int getPolarity()
           {
               return (status & IO_STATUS_ACTIVE_HI) ? 1 : 0;
           }
   
           void setActiveHi()
           {
               setPolarity(1);
           }
           void setActiveLo()
           {
               setPolarity(0);
           }
   
           void wakeOnActive(int wake)
           {
               if (wake)
                   status |= IO_STATUS_WAKE_ON_ACTIVE;
               else
                   status &= ~IO_STATUS_WAKE_ON_ACTIVE;
           }
   
           int isWakeOnActive()
           {
               return (status & IO_STATUS_WAKE_ON_ACTIVE) ? 1 : 0;
           }
   
           virtual void connect(PinPeripheral &p, bool deleteOnRelease = false)
           {
               p.deleteOnRelease = deleteOnRelease;
           }
           virtual void disconnect()
           {
           }
   
           virtual ~Pin()
           {
           }
       };
   
   }
   
   #endif
